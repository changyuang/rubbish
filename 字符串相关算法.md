# Manacher算法

**作用**
查找一个字符串的最长回文字串的线性方法

传统查找回文子串的方法：
- O(n^3) 枚举子串的左右端点，并判断由左右端点构成的子串是否是回文串
- O(n^2) 枚举子串的中心点，并向左右扩散[这种情况需要注意奇偶]

### 算法处理步骤
1. 预处理：添加分隔符，在字符串的首位、相邻子醋中插入分隔符，例如“ababa”添加分隔符后就变成了“#a#b#a#b#a”
注：
- 分隔符是一个自负，种类也只有一个，并且这个字符一定不能是原始字符串中出现过的字符
- 加入了分隔符之后，使得间隙有了具体的位置。并且新字符串中任意一个回文子串在原始字符串中的一定能找到唯一的一个回文子串与之对应
- 新字符串的回文子串一定是奇数
- 新字符串的回文字串一定以分隔符作为两边的边界，因此分隔符起到“哨兵”的作用

2. 计算辅助数组p：辅助数组p记录了新字符串中以每个字符为中心的回文子串的信息。手动计算方法仍然是“中心扩散法”，此时记录以当前字符为中心，向左右两边同时扩散，记录能够扩散的最大步数。

以字符串“abbabb”为例，说明如何手动计算得到辅助数组p，要计算的就是下边的表格

| char | # | a | # | b | # | b | # | a | # | b | # | b | # |
| :------: | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| p | 

具体处理步骤：
- 以char[0] = '#' 为中心，同时向左边右边扩散，走一步就碰到边界了，因此能扩散的步数为0，p[0] = 0
- 以char[1] = 'a'为中心，同时向左边右边扩散，走1步，都是‘#’,构成回文子串，于是再向两边扩散，左边碰到边界，最多能扩散的步数为1，因此p[1] = 1
- 其他同理，p[2] = 0,p[3] = 1,p[4] = 4,p[5] = 1.......

最终表格如下图所示
| char | # | a | # | b | # | b | # | a | # | b | # | b | # |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| p | 0 | 1 | 0 | 1 | 4 | 1 | 0 | 5 | 0 | 1 | 2 | 1 | 0 | 

辅助数组p的最大值为5，对应了"abbabb"的最长回文子串:"bbabb",这个结论具有一般性，即**辅助数据p的最大值就是最长回文子串的长度**

***目前解决了O(n^2)解法中奇偶不同的情况，统一为了只存在奇数回文串的场景，但是时间复杂度仍然是O(n^2)***

手动计算存在的问题：对新字符串的每一个位置进行中心扩散，会导致字符串的每一个字符被访问多次。科学家Manacher改进了这种算法，使得在填写新的辅助数组p的值的时候，能够参考已经填写过的辅助数组p的值，使得新字符串每个字符只访问了一次，整体时间复杂度降低到了O(n)


具体的做法是：在遍历的过程中，除了循环变量i以外，还需要记录两个变量，分别是maxRight和center

**maxRight:**表示记录当前向右扩展的最远边界，即从开始到现在使用“中心扩散法”能够得到的回文子串，它能够延伸到的最右端的位置。

注：
- 向右最远 是在计算辅助数组p的过程中，向右边扩散能走的索引最大的位置。得到一个maxRight所对应的回文子串，并不一定是当前得到的“最长回文子串”，很可能的一种情况是，某个回文子串可能比较短，但是正好在整个字符串比较靠后的位置
- 扫描是从左向右的，maxRight能够提供的信息最多，是一个重要的分类讨论标准，所以需要一个变量来记录它。

**center:**与maxRight相关的一个变量，是maxRight的回文中心的索引值。一个center对应一个maxRight

**具体操作流程：**
1. 当i >= maxRight时候，就是一开始以及刚刚把一个回文字串扫描完的情况，此时只能够根据“中心扩散法”一个一个扫描，逐渐扩大maxRight
2. 当i < maxRight时候，假设i关于center中心对称的下标为mirror
$$(mirror + i) / 2 = center$$
$$mirror = 2 * center - i$$

根据p[mirror]的值 分为一下三种情况：
- p[mirror] < maxRight - i   此时p[i] = p[mirror]
- p[mirror] == maxRight - i  此时先让p[i] = p[mirror] 之后使用中心扩散法继续扩散
- p[mirror] > maxRight - i   此时p[i] = maxRight - i

就可以得到最终的结果

# KMP算法


# 前缀树


# 后缀树

